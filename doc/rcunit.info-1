This is rcunit.info, produced by makeinfo version 4.2 from rcunit.texi.

INFO-DIR-SECTION Testing
START-INFO-DIR-ENTRY
* RCUNIT: (rcunit).        A robust C unit testing framework
END-INFO-DIR-ENTRY

This document contains information on how to use RCUNIT, a robust C
unit testing framework.

   This is Edition 0.9, last updated 9 October 2006.

   Copyright ((C))  2006  Jerrico L. Gamis
(<jecklgamis@users.sourceforge.net>)

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
   

File: rcunit.info,  Node: Top,  Next: Introduction to RCUNIT,  Up: (dir)

About This Document
*******************

This document contains information on how to use RCUNIT, a robust C
unit testing framework.

   This is Edition 0.9, last updated 9 October 2006.

   Copyright ((C))  2006  Jerrico L. Gamis
(<jecklgamis@users.sourceforge.net>)

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, no Front-Cover Texts, and
     no Back-Cover Texts.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
   
* Menu:

* Introduction to RCUNIT::
* Building RCUNIT::
* The RCUNIT Framework::
* RCUNIT Framework Interfaces::
* Other RCUNIT Facilities::
* Sample Test Codes::
* Sample Test Run Report::
* Sample Log File::
* Copying This Manual::
* Submitting Bugs::
* Acknowledgements::


File: rcunit.info,  Node: Introduction to RCUNIT,  Next: Building RCUNIT,  Prev: Top,  Up: Top

Introduction to RCUNIT
**********************

   RCUNIT stands for Robust C Unit.  It is a small framework for
testing C programs. Similar to other unit testing frameworks, RCUNIT is
a framework used for creating repeatable tests.

* Menu:

* Introduction to Test Design Methods::
* Writing a Simple Repeatable Test::


File: rcunit.info,  Node: Introduction to Test Design Methods,  Next: Writing a Simple Repeatable Test,  Up: Introduction to RCUNIT

Introduction to Test Design Methods
===================================

   RCUNIT is essentially a black-box testing tool. Black box testing,
also called functional or behavioral testing,  is a test method
designed to test the functional requirements of a system. It has no
knowledge of the internal structure of the systems as opposed to the
white box testing, also called structural testing, where different
execution paths are tested. While black box testing can find functional
requirements misses and interface problems, white box testing can find
implementation problems of the functional requirements.

   RCUNIT is also a regression testing tool used for finding regression
bugs. Regression bugs are consequences of program changes caused either
by fixing a bug or by adding a new functionality. Creating repeatable
tests is one way of finding regression bugs.


File: rcunit.info,  Node: Writing a Simple Repeatable Test,  Prev: Introduction to Test Design Methods,  Up: Introduction to RCUNIT

Writing a Simple Repeatable Test
================================

   Creating a repeatable test in RCUNIT is straightforward :  create a
test function for the function to be tested, use one or more assertion
statements inside the test function to assert conditions, register the
test function to the framework, execute the test function using the
framework interfaces, and view the auto-generated test run results. The
example below demonstrates these procedures.

   Assume we have a function that calculates the sum of two integers.

int calc_sum(int x, int y) {
    return(x+y);
}

   To test this function, we create a test function, say
`test_calc_sum()'.


RCU_DEF_TEST_FUNC(test_calc_sum,param){
    RCU_ASSERT( calc_sum(-1,-1) == -2);
    RCU_ASSERT(calc_sum(0,0) == 0);
}

   The `RCU_DEF_TEST_FUNC' is an RCUNIT macro for defining a test
function. The above code is the same as

void test_calc_sum(void *param){
    RCU_ASSERT( calc_sum(-1,-1) == -2);
    RCU_ASSERT(calc_sum(0,0) == 0);
}

   There are two things to note in this test function: the function
prototype and the assertion statements. First, the function format of
this function is a requirement of RCUNIT. All test functions must have
this format. In the current functionality, the parameter is not used
and is set to a null pointer when the test function is executed by the
framework.  Second, the assertion statements are used to assert
conditions. For instance, the first assertion statement asserts that
the sum of `-1' and `-1' is `-2'.

   Next, the test function is registered to the framework. Note that
the framework must be initialized first.


int main(int argc,char **argv){
int ercd;

    /** Initialize framework */
    ercd = rcu_init();
    if (ercd == RCU_E_NG){
        return(-1);
    };

    /** Register the test function to the default test module. The
        function parameters are the test module, the test function
        entry point, init function, destroy function, test function
        name, and test run enable flag.
    */
    ercd = rcu_add_test_func(RCU_DEFAULT_MODULE,test_calc_sum,
        RCU_NULL, RCU_NULL,"test_calc_sum", RCU_TRUE))

    if (ercd == RCU_E_NG){
        rcu_destroy();
        return(-1);
    }

    /** Run the logical test machine */
    rcu_run_test_mach();

    /** Destroy the framework */
    rcu_destroy();

    return(0);
}

   Now, when the test function is executed , i.e. by executing the
`rcu_run_test_mach()' function,  and one of the assertion statements
failed, the assertion failure is recorded by the framework. After all
the test functions are executed, the framework generates a test run
report containing the assertion failures encountered.

   Finally, assuming the  function `calc_sum()' is revised, the same
procedures can be performed again and the test run results are
rechecked. If there are no more assertion failure records, then the
function is assumed to be working correctly. Of course, it is the
responsibility of the user to create as many assertion statements as
necessary in order to fully test the function.

   Fundamentally, this is how a repeatable test is done using RCUNIT.


File: rcunit.info,  Node: Building RCUNIT,  Next: The RCUNIT Framework,  Prev: Introduction to RCUNIT,  Up: Top

Building RCUNIT
***************

   Using RCUNIT requires linking with the RCUNIT library. That is,
RCUNIT is assumed to be tightly integrated with the user test codes.
Building the RCUNIT library requires an ANSI/ISO compliant C compiler.
The source codes have been compiled and tested in the following
platforms.

   In the Unix/Linux platform :

   * gcc version 3.2.2 (Red Hat Linux kernel 2.4.20-8)

   * gcc version 3.3.6 (Knoppix Linux kernel 2.6.11)

   In the Windows platform :

   * Microsoft ((C)) 32-bit C/C++ Optimizing Compiler Version
     12.00.8168 for 80x86 (Windows XP)

* Menu:

* Required C Library Functions and Macros::
* Configuration Flags::


File: rcunit.info,  Node: Required C Library Functions and Macros,  Next: Configuration Flags,  Up: Building RCUNIT

Required C Library Functions and Macros
=======================================

   RCUNIT uses the following C library functions.

     String functions : `strcpy', `strlen' `strcmp'
     Memory functions : `malloc', `free', `memset', `memcpy'
     Printing functions : `fprintf' , `sprintf'
     Non-local jump functions : `setjmp', `longjmp'
     Time functions: `time', `ctime'

   RCUNIT also uses the following pre-defined ANSI/ISO C macros.

     `__FILE__', `__LINE__', `__DATE__', `__TIME__'


File: rcunit.info,  Node: Configuration Flags,  Prev: Required C Library Functions and Macros,  Up: Building RCUNIT

Configuration Flags
===================

   The file `rcunit_config.h' contains the RCUNIT configuration
switches. RCUNIT also uses another configuration file
`rcunit_config_env.h' that contains preprocessor symbols corresponding
to the probed features of the platform (e.g. C library functions ) and
other information such as version numbers. In the Unix/Linux build,
this file is automatically created in the configuration process (i.e.
invocation of the `configure' script). In other platforms where the
`configure' script cannot be used, the bundled configuration header
file must be edited manually. `rcunit_config_env.h' is included by the
main configuration header file `rcunit_config'.

`RCU_DEBUG'
     This symbol must be defined to enable debug mode. In the
     Unix/Linux build, this macro is automatically defined if the
     `--enable-debug=yes' option is given in the invocation of
     `configure' script. In Windows and other platforms, the symbol can
     be defined using the -D option of the compiler.

   The following preprocessor symbols are defined inside
`rcu_config.h'. These are enabled by setting a non-zero value.

`RCU_ENABLE_ANSI_FILE_IO'
     If set, tells RCUNIT that an ANSI file I/O is available. This is
     enabled by default.

`RCU_ENABLE_MALLOC_ALIGNMENT'
     Enables memory allocation alignment. All internal memory
     allocations used by RCUNIT are aligned to the native integer size
     (sizeof(int)).  This is enabled by default.

`RCU_ENABLE_MTRACE'
     Enables memory leak check facility. This is enabled by default.

`RCU_ENABLE_EMIT_PLAINTEXT_LOG'
     Enables plain text log file instead of HTML. This is disabled by
     default.

`RCU_ENABLE_EMIT_PLAINTEXT_REPORT'
     Enables plain text test run report file instead of HTML. This is
     disabled by default.

   If `RCU_ENABLE_ANSI_FILE_IO' is disabled,
`RCU_ENABLE_EMIT_PLAINTEXT_LOG' and `RCU_ENABLE_EMIT_PLAINTEXT_REPORT'
are always enabled by the framework.


File: rcunit.info,  Node: The RCUNIT Framework,  Next: RCUNIT Framework Interfaces,  Prev: Building RCUNIT,  Up: Top

The RCUNIT Framework
********************

   The chapter contains information on the RCUNIT framework entities
and operations.

* Menu:

* Data Types:: RCUNIT-defined data types
* Test Entities:: Logical entities for structuring tests
* Test Entity Operations:: Operations for structuring and running tests
* The Test Machine:: Logical entity that executes the tests
* Error Management:: Error handling in RCUNIT
* Log Management:: Log handling in RCUNIT
* Output Mechanism:: RCUNIT's output redirection mechanism


File: rcunit.info,  Node: Data Types,  Next: Test Entities,  Up: The RCUNIT Framework

Data Types
==========

   The following are the commonly used RCUNIT data types.

`RCU_INT'
     Integer data type

`RCU_CHAR'
     Character data type

`RCU_VOID'
     Void data type

`RCU_GENERIC_FUNCTION'
     This is the format of all the function entry points used inside
     the framework.  This applies to test function, test function init
     and destroy functions, test module init and destroy functions,
     test run hook, assertion hook, log handler, and output handler.
     The RCU_GENERIC_FUNCTION has the definition `typedef
     void(*RCU_GENERIC_FUNCTION)(void *)'. That is, all the function
     entry points have the form `void test_xxx(void *param)'.

`RCU_TEST_FUNCTION'
     Test function data type

`RCU_TEST_FUNCTION_ENTRY'
     Test function table entry data type

`RCU_TEST_MODULE'
     Test module data type

`RCU_TEST_MODULE_ENTRY'
     Test module table entry data type

`RCU_TEST_REGISTRY'
     Test registry data type

`RCU_OUTPUT_RECORD'
     Output record data type

`RCU_LOG_HANDLER'
     Log handler data type

     /** @brief Log handler data structure */
     typedef struct rcu_log_handler{
     RCU_GENERIC_LIST link;              /**< Link to other handlers (Used by the framework) */
     RCU_GENERIC_FUNCTION init;          /**< Initialization function */
     RCU_GENERIC_FUNCTION destroy;       /**< Destruction function */
     RCU_GENERIC_FUNCTION log_impl;      /**< Log implementation */
     }RCU_LOG_HANDLER;

`RCU_LOG_RECORD'
     Log record data type

     /** @brief Log record */
     typedef struct rcu_log_record {
     RCU_INT level;                      /**< Log level */
     RCU_CHAR *data;                     /**< Log data */
     }RCU_LOG_RECORD;

`RCU_OUTPUT_HANDLER'
     Output handler data type

     /** @brief Output handler data structure */
     typedef struct rcu_output_handler{
     RCU_GENERIC_LIST link;              /**< Link to other handlers (Used by the framework) */
     RCU_GENERIC_FUNCTION init;          /**< Initialization function */
     RCU_GENERIC_FUNCTION destroy;       /**< Destruction function */
     RCU_GENERIC_FUNCTION out_impl;      /**< Output implementation */
     }RCU_OUTPUT_HANDLER;

`RCU_OUTPUT_RECORD'
     Output record

     /** @brief Output record */
     typedef struct rcu_output_record {
     RCU_VOID *data;                     /**< Output data */
     }RCU_OUTPUT_RECORD;

`RCU_FAILURE_RECORD'
     Assertion failure record data type

     /**  @brief  Failure record entry */
     typedef struct rcu_failure_record {
     RCU_GENERIC_LIST link;              /**< Link to the next/previous record */
     RCU_CHAR *info;                     /**< Information */
     }RCU_FAILURE_RECORD;

   The following are the commonly used symbols.
`RCU_FALSE,RCU_TRUE'
     Boolean definitions

`RCU_NULL'
     Null pointer reference

`RCU_DEFAULT_REGISTRY'
     Refers to the default test registry

`RCU_DEFAULT_MODULE'
     Refers to the default test module

   When defining or declaring function entry points, the user is
suggested to use the helper macros. *Note Helper Macros::.


File: rcunit.info,  Node: Test Entities,  Next: Test Entity Operations,  Prev: Data Types,  Up: The RCUNIT Framework

Test Entities
=============

   The following are the RCUNIT test entities.

* Menu:

* Test Function:: The test workarea
* Test Module:: Groups one or more test functions
* Test Registry:: Groups one or more test modules
* The Default Test Registry and Test module::


File: rcunit.info,  Node: Test Function,  Next: Test Module,  Up: Test Entities

Test Function
-------------

   A test function is a work area for testing a particular C function.
Inside this function, the user calls assertion statements to assert
specific conditions. The condition depends on the results of operations
performed on the C function being tested. For example it can be an
assertion of the function's return value or output parameter value.
Failed assertion conditions are recorded and collected after all the
test functions have been executed.

   A test function is identified by a user-defined or framework-defined
name and function entry point address (i.e. the name of the function
entry point itself). It can have optional initialization (init) and
destruction (destroy) functions, which are executed before and after
the main test function, respectively. A test function must be
registered to at most one test module and it can be registered as
disabled or enabled. A disabled test function is not executed during a
test run.

   A group of test functions can be collectively registered to a test
module. The test functions are grouped in a table, called the test
function table, before they are added to a particular test module.

   The sample code below shows how to define a test function, an init
function or  destroy function, and a test function table.

   Test function:

RCU_DEF_TEST_FUNC(test_xxx,param){
}

   Init function:

RCU_DEF_INIT_FUNC(test_xxx_init,param){
}

   Destroy function:

RCU_DEF_DESTROY_FUNC(test_xxx_destroy,param){
}

   The `param' is an implicit pointer to a void data type (RCU_VOID*).
When the framework invokes these function entry points, the param is
just set to RCU_NULL. The actual parameter names are user-defined.

   Test function table :

RCU_DEF_FUNC_TBL(xxx_func_tbl)
    RCU_INC_FUNC_ENTRY_AUTONAME(test_xxx,test_xxx_init,test_xxx_destroy,RCU_TRUE)
          or
    RCU_INC_FUNC_ENTRY("test_xxx",test_xxx,test_xxx_init,test_xxx_destroy,RCU_TRUE)
    ...
RCU_DEF_FUNC_TBL_END

   The `RCU_INC_FUNC_ENTRY_AUTONAME' macro automatically generates the
test function's name from the actual function name. To use a
user-defined one, simply use the `RCU_INC_FUNC_ENTRY' macro.

   *Note Helper Macros::.


File: rcunit.info,  Node: Test Module,  Next: Test Registry,  Prev: Test Function,  Up: Test Entities

Test Module
-----------

   A test module holds one or more test functions. In other test
frameworks, this is also called a test suite. A test module can be a
user-defined module or the default test module provided by the
framework.

   A test module is identified by a name, can have optional init and
destroy functions that are executed before and after completion of all
test functions, and must be registered to at most one test registry.
Similar to a test function, a test module can be created as disabled or
enabled.

   A group of test modules can be collectively registered to a test
registry.  The modules are grouped in a table called test module table,
before they are added to a particular test registry.

   The sample code below shows how to define a test module, an init
function, a destroy function, and a test module table

   Test module:

RCU_DEF_TEST_MOD(mod_xxx)

   Init function:

RCU_DEF_INIT_FUNC(mod_xxx_init,param){
}

   Destroy function:

RCU_DEF_DESTROY_FUNC(mod_xxx_destroy,param){
}

   Test module table:

RCU_DEF_MOD_TBL(xxx_mod_tbl)
    RCU_INC_MOD("m1",RCU_NULL,RCU_NULL,xxx_func_tbl_1,RCU_TRUE);
    RCU_INC_MOD("m2",RCU_NULL,RCU_NULL,xxx_func_tbl_2,RCU_FALSE);
RCU_DEF_MOD_TBL_END

   The macro `RCU_DEF_TEST_MOD' is used only when a test module is is
not part of a test module table. Otherwise, only the test module name
is required in the test module table entry. In the sample test module
table, a test module named "m1" is defined with no init or destroy
function and is registered as enabled. The next entry is for a test
module named "m2" with no init or destroy function, and is registered
as disabled.

   *Note Helper Macros::.


File: rcunit.info,  Node: Test Registry,  Next: The Default Test Registry and Test module,  Prev: Test Module,  Up: Test Entities

Test Registry
-------------

   A test registry provides another level of hierarchy. It holds one or
more test modules. A test registry can be a user-defined registry or
the default test registry provided by the framework.

   A test registry is identified by a name, can be created as disabled
or enabled, but does not have init or destroy functions. A test
registry can be registered to the test machine only once.

   The sample code below shows how to define a test registry


RCU_DEF_TEST_REG(reg_xxx)


File: rcunit.info,  Node: The Default Test Registry and Test module,  Prev: Test Registry,  Up: Test Entities

The Default Test Registry and Test module
-----------------------------------------

   Upon initialization of the framework, the default test registry and
test module are automatically created. The default test module is
automatically registered to the default test registry. The default test
registry is named as  "default-reg". This name cannot be used by
user-defined test registries. The test registry can be referenced using
a null name or reference (For uniformity, the RCUNIT-defined macro
`RCU_DEFAULT_REGISTRY' can be used).

   The test module is named "default-mod". This name cannot be used in
user-defined test module. Similar to the default test registry, it can
be also referenced using a null name or reference. (For uniformity, the
RCUNIT-defined macro `RCU_DEFAULT_MODULE' can be used).

   The default test registry and test module are automatically
destroyed, including all the entities registered entities, when the
test machine is destroyed.


File: rcunit.info,  Node: Test Entity Operations,  Next: The Test Machine,  Prev: Test Entities,  Up: The RCUNIT Framework

Test Entity Operations
======================

   The following are the operations on the test entities.

* Menu:

* Test Entity Creation and Registration::
* Test Entity Destruction::
* Test Entity Execution::
* Test Entity Database Dumping::


File: rcunit.info,  Node: Test Entity Creation and Registration,  Next: Test Entity Destruction,  Up: Test Entity Operations

Test Entity Creation and Registration
-------------------------------------

   Before a test function can be registered to a test module, the test
module must be created and registered first into a test registry.
Furthermore, the test registry must be created and registered first to
the test machine. In short, a higher level test entity must be created
and registered first before any lower level test entity can be
registered. The entity registration process can be summarized as:

  1. Creating a test registry

  2. Registering the test registry to the test machine

  3. Creating a test module or test module table

  4. Registering the test module  or test module table

  5. Registering a test function or test function table

   If the default test registry or test module is to be used, the
creation and registration steps are no longer necessary.

   *Note Test Entity Interfaces::.


File: rcunit.info,  Node: Test Entity Destruction,  Next: Test Entity Execution,  Prev: Test Entity Creation and Registration,  Up: Test Entity Operations

Test Entity Destruction
-----------------------

   When test entities are already registered to the test machine,
destroying the test machine will destroy all of the entities. That is,
all test entity references will be invalidated. If a particular test
entity is not yet registered (i.e. not known by the test machine), then
the user must manually destroy it using the interface functions
provided. Failure to do so will result in a memory leak.

   *Note Test Entity Interfaces::.


File: rcunit.info,  Node: Test Entity Execution,  Next: Test Entity Database Dumping,  Prev: Test Entity Destruction,  Up: Test Entity Operations

Test Entity Execution
---------------------

   The test execution, also called a test run, is the process of
executing test entities. All registered test entities in the test
entity database are executed if the entities are registered as
"enabled". The `rcu_run_test_mach()' function is used to start a test
run.

   The user can optionally set a test run callback function (also
called a test run hook). A test run callback function is invoked at the
start and at the end of a test run. The sample code below shows how to
define a test run hook.


RCU_DEF_TEST_RUN_HOOK(xxx_run_hook,param){
RCU_INT run_event;

    run_event = RCU_GET_RUN_EVT_TYPE(param);

    if (run_event == RCU_TEST_RUN_STARTED){

        /** code for test run start event */

   }else if (run_event == RCU_TEST_RUN_FINISHED){

       /** code for test run end event */

   }

   The test run hook function can be setup using the
`rcu_set_run_hook()' interface.

   *Note Test Entity Interfaces::.

   *Note Helper Macros::.


File: rcunit.info,  Node: Test Entity Database Dumping,  Prev: Test Entity Execution,  Up: Test Entity Operations

Test Entity Database Dumping
----------------------------

   RCUNIT provides an interface for dumping the test entity database.
This is useful for verifying the layout of the test entities. The test
entity database is dumped into the RCUNIT log.

   *Note Test Entity Interfaces::.


File: rcunit.info,  Node: The Test Machine,  Next: Error Management,  Prev: Test Entity Operations,  Up: The RCUNIT Framework

The Test Machine
================

   The test machine is a  logical entity that executes the tests. It is
initialized on framework initialization and is destroyed on framework
destruction. Furthermore, all RCUNIT interfaces can be used only after
the framework has been initialized.

* Menu:

* Test Entity Database:: Holds the test entities
* Assertion Engine::Records assertion failures
* Test Run Report Generator::Generates test run report


File: rcunit.info,  Node: Test Entity Database,  Next: Assertion Engine,  Up: The Test Machine

Test Entity Database
--------------------

   The test entity database is the main placeholder of all the test
entities.  All the test entities (functions, modules, and registries)
must be registered to the test database before before it can be
executed.

   Below is the runtime layout of the test entity database.


Test Entity Database
    + Default registry
    |   + Default module
    |       +- Test Function A-1
    |       +- Test Function A-2
    |       +- ...
    |       +- Test Function A-N
    +- Test registry 1
    |    +- Test Module 1
    |    |  +- Test Function B-1
    |    |  +- Test Function B-2
    |    |  +- ...
    |    |  +- Test Function B-N
    |   +- Test Module 2
    |   +- ...
    |   +- Test Module N
    +- Test registry 2
    +- ...
    +- Test registry N


File: rcunit.info,  Node: Assertion Engine,  Next: Test Run Report Generator,  Prev: Test Entity Database,  Up: The Test Machine

Assertion Engine
----------------

   The assertion engine is a logical processing inside the test
machine. Its primary function is to record all the assertion failures
encountered during a test run. The assertion engine relies on the
exception mechanism which handles the abortion of a currently executing
test function when a fatal assertion failure is encountered.

   The assertion statements are the interface between the user test
code and the assertion engine. An assertion statement can be a fatal or
non-fatal one. An assertion statement that failed is recorded by the
assertion engine. Furthermore, a fatal assertion failure aborts a
currently executing code.

   Assertion statements can be called in any of following code
locations. The behavior during an assertion failure is also described.

   * Test function - An assertion failure is recorded and the test
     function result is set as "Failed". A fatal assertion failure
     aborts execution of this function.

   * Test function init function - An assertion failure is recorded. A
     fatal or a non-fatal assertion failure aborts execution of this
     function. The test function is no longer executed and the result
     is set as "Aborted". Note that this is an implied failure.

   * Test function destroy function - An assertion failure is recorded.
     The test function result is set as "Failed" even if there are no
     assertion failures encountered in the test function itself.

   * Test module init function - An assertion failure is recorded. A
     fatal or a non-fatal assertion failure aborts execution of this
     function. The test functions, and corresponding init or destroy
     functions if set, are no longer executed.

   * Test module destroy function - An assertion failure is recorded.

   Assertions failures encountered from other code locations are
considered non-test run assertions. *Note Non-Test Run Assertions::.


File: rcunit.info,  Node: Test Run Report Generator,  Prev: Assertion Engine,  Up: The Test Machine

Test Run Report Generator
-------------------------

   The test run report generator collects the test run results and
generates a test run report after a test run. The report contains the
following information.

   _Test run summary_

   * Total number of registered test registries

   * Number of completed test registries (classified as Passed or
     Failed)

   * Total number of registered test modules

   * Number of completed test modules  (classified as Passed, Failed,
     or Aborted)

   * Total number of registered test functions

   * Number of completed test functions (classified as either Passed,
     Failed, or Aborted).

   * Total number of assertions found (classified as Passed, Failed
     (non-fatal), or Failed (fatal))

   _Per test registry run statistics_

   * Total number of registered test modules

   * Number of completed test modules

   * Number of passed test modules

   * Number of failed test modules

   _Per test module run statistics_

   * Total number of registered test functions

   * Number of completed test functions

   * Number of passed test functions

   * Number of failed test functions

   * Number of aborted test functions

   _Per test function run statistics_

   * Test result status ("Passed", "Failed", "Aborted", "Disabled")

   * Total number of assertions found

   * Total number of failed assertions

   * List of failure records in the following format

   For non-fatal assertion failures :
`<source file name>(<line number>) : fail : <condition or message>'

   For fatal assertion failures :
`<source file name>(<line number>) : fatal : <condition or message>'

* Menu:

* Definition of "Failed" Result::
* Test Run Reporting::


File: rcunit.info,  Node: Definition of "Failed" Result,  Next: Test Run Reporting,  Up: Test Run Report Generator

Definition of "Failed" Result
.............................

   * A test registry is considered "Failed" if one of the registered
     test modules failed

   * A test module is considered "Failed" if one of the registered test
     functions or the module's init function failed

   * A test function is considered "Failed" if there is an asseertion
     failure encountered or the test function's init function failed


File: rcunit.info,  Node: Test Run Reporting,  Prev: Definition of "Failed" Result,  Up: Test Run Report Generator

Test Run Reporting
..................

   If an ANSI file I/O facility is available, RCUNIT generates an HTML
test run report (`rcunit_test_run_report.html') or a plaintext test run
report (`rcunit_test_run_report.txt') if the framework is recompiled
with `RCU_ENABLE_EMIT_PLAINTEXT_REPORT' enabled. However if an ANSI I/O
facility is not available, the report is is directed using RCUNIT's
output redirection mechanism. Furthermore, the redirected report is in
plain text format. *Note Output Mechanism::.


File: rcunit.info,  Node: Error Management,  Next: Log Management,  Prev: The Test Machine,  Up: The RCUNIT Framework

Error Management
================

   RCUNIT uses simplified error handling. All RCUNIT interfaces return
only two possible values : a successful operation code or a failure
operation code. For integer return types, the return is either an
RCU_E_OK or RCU_E_NG. For pointer return types, the return is either a
null or a non-null pointer. The specific error code and error string
can be retrieved using the error management interfaces.

   The framework cannot catch run time system exception such as an
invalid memory reference. The integrity of the test run report cannot
be guaranteed in such situation.

   *Note Error Management Interfaces::.


File: rcunit.info,  Node: Log Management,  Next: Output Mechanism,  Prev: Error Management,  Up: The RCUNIT Framework

Log Management
==============

   In a typical test run  the user is concerned mainly with the test
run report. However, if there are failures in the internal processing,
such as a memory allocation failure, the user can check the log file
for the details of the error. If an ANSI file I/O facility is
available, the  framework generates an HTML file or a plain text file
if the framework is recompiled with `RCU_ENABLE_EMIT_PLAINTEXT_LOG'
enabled. On the other hand, if an ANSI file I/O facility is not
available, the logs are redirected to the framework's output
redirection mechanism. *Note Output Mechanism::. Redirected logs are in
plain text format.

   RCUNIT differentiates a log message as information, warning, or a
fatal log. The framework provides interfaces for setting and getting
the current log level. The setting can be one of the following

   * Logging is turned off

   * Logger emits all log message types

   * Logger emits fatal log messages only

   * Logger emits warning and fatal messages only

   Log Handlers

   RCUNIT uses log handlers to implement actual logging. Using log
handlers, the user can redirect log data to a specific device or
interface. An example is serial log handler, an IDE's debug output
window log handler, or a socket-based log handler. If an ANSI file I/O
facility is available, the framework provides a default file log
handler and a standard output `stdout' log handlers.

   The sample code below shows how to setup a log handler.


RCU_LOG_HANDLER xxx_log_hnd;

RCU_DEF_INIT_FUNC(xxx_log_hnd_init,param){
    /** Code to init log handler */
}

RCU_DEF_DESTROY_FUNC(xxx_log_hnd_destroy,param){
    /** Code to destroy log handler */
}

RCU_DEF_LOG_HANDLER_IMPL(xxx_log_hnd_log_impl,param){
RCU_LOG_RECORD *log_rec;
    out_rec = (RCU_LOG_RECORD*)param;
    /** Code to implement the actual log */
}

void setup_log_handler(){

    /** Setup callback functions */
    xxx_log_hnd.init = xxx_log_hnd_init;
    xxx_log_hnd.destroy = xxx_log_hnd_destroy;
    xxx_log_hnd.out_impl = xxx_log_hnd_out_impl;

    /** Register the log handler */
    rcu_add_log_hnd(&log_hnd);
    ...
    /** Remove the log handler */
    rcu_del_log_hnd(&log_hnd);

}

   To be able to immediately receive logs, the log handler must be
registered right after framework initialization.

   *Note Log Management Interfaces::.


File: rcunit.info,  Node: Output Mechanism,  Prev: Log Management,  Up: The RCUNIT Framework

Output Mechanism
================

   If an ANSI file I/O facility is available (`
RCU_ENABLE_ANSI_FILE_IO' is enabled in file `rcu_config') in the
system, RCUNIT uses it to create the log file and the test run report.
Otherwise, RCUNIT uses an output redirection mechanism in the form of
callback mechanism. Essentially, it is the user that must provide the
actual implementation of the output by implementing required callback
functions. These callback functions are collectively called as output
handler.

   The sample code below shows how to setup an output handler.


RCU_OUTPUT_HANDLER xxx_out_hnd;

RCU_DEF_INIT_FUNC(xxx_out_hnd_init,param){
    /** Code to initialize output handler */
}

RCU_DEF_DESTROY_FUNC(xxx_out_hnd_destroy,param){
    /** Code to destroy output handler */
}

RCU_DEF_OUT_HANDLER_IMPL(xxx_out_hnd_out_impl,param){
RCU_OUTPUT_RECORD *out_rec;
    out_rec = (RCU_OUTPUT_RECORD*)param;
    /** Code to implement the actual output */
}

void setup_output_handler(){

    /** Setup callback functions */
    xxx_out_hnd.init = xxx_out_hnd_init;
    xxx_out_hnd.destroy = xxx_out_hnd_destroy;
    xxx_out_hnd.out_impl = xxx_out_hnd_out_impl;

    /** Register the output handler */
    rcu_add_out_hnd(&out_hnd);
    ...
    /** Remove the output handler */
    rcu_del_out_hnd(&out_hnd);

}


File: rcunit.info,  Node: RCUNIT Framework Interfaces,  Next: Other RCUNIT Facilities,  Prev: The RCUNIT Framework,  Up: Top

RCUNIT Framework Interfaces
***************************

   This chapter provides summary information on the RCUNIT interfaces.
See the separate source code documentation for the details of each
interface.

* Menu:

* The RCUNIT Header and Library File::
* The Main Framework Interfaces::
* Test Entity Interfaces::
* Assertion Macros::
* Helper Macros::
* Error Management Interfaces::
* Log Management Interfaces::


File: rcunit.info,  Node: The RCUNIT Header and Library File,  Next: The Main Framework Interfaces,  Up: RCUNIT Framework Interfaces

The RCUNIT Header and Library File
==================================

   All the RCUNIT data types, definitions, interface function
prototypes,  etc.  are defined directly  or indirectly inside
`rcunit.h' header file. The user must include this file to be able to
use the framework. Furthermore, the test codes must be linked with the
RCUNIT library.


File: rcunit.info,  Node: The Main Framework Interfaces,  Next: Test Entity Interfaces,  Prev: The RCUNIT Header and Library File,  Up: RCUNIT Framework Interfaces

The Main Framework Interfaces
=============================

   Below are the main framework interfaces.

`RCU_INT rcu_init()'
     Initializes the framework

`RCU_INT rcu_destroy()'
     Destroys the framework.

`RCU_INT rcu_run_test_mach()'
     Runs the test machine

`RCU_INT rcu_dump_test_dbase()'
     Dumps the test entity database

`RCU_INT rcu_set_run_hook(RCU_GENERIC_FUNCTION run_hook)'
     Registers a test run callback function

`RCU_INT rcu_set_assert_hook(RCU_GENERIC_FUNCTION assert_hook)'
     Sets a non - test run assertion hook

`RCU_INT rcu_dump_asserts()'
     Dumps non - test run assertions found


File: rcunit.info,  Node: Test Entity Interfaces,  Next: Assertion Macros,  Prev: The Main Framework Interfaces,  Up: RCUNIT Framework Interfaces

Test Entity Interfaces
======================

* Menu:

* Test Registry Interfaces::
* Test Module Interfaces::
* Test Function Interfaces::


File: rcunit.info,  Node: Test Registry Interfaces,  Next: Test Module Interfaces,  Up: Test Entity Interfaces

Test Registry Interfaces
------------------------

   Below are the test registry - related interfaces.

`RCU_TEST_REGISTRY *rcu_cre_test_reg(const RCU_CHAR *name, RCU_INT enable)'
     Creates a test registry

`RCU_INT rcu_destroy_test_reg(RCU_TEST_REGISTRY *reg)'
     Destroys a test registry

`RCU_INT rcu_add_test_reg(RCU_TEST_REGISTRY *reg)'
     Registers a test registry to the test machine


File: rcunit.info,  Node: Test Module Interfaces,  Next: Test Function Interfaces,  Prev: Test Registry Interfaces,  Up: Test Entity Interfaces

Test Module Interfaces
----------------------

   Below are the test module - related interfaces.

`RCU_TEST_MODULE *rcu_cre_test_mod(const char *name, RCU_GENERIC_FUNCTION RCU_INT, RCU_GENERIC_FUNCTION destroy, RCU_INT enable)'
     Creates a test module

`int rcu_destroy_test_mod(RCU_TEST_MODULE *mod)'
     Destroys a test module

`RCU_INT rcu_add_test_mod(RCU_TEST_REGISTRY *reg, RCU_TEST_MODULE *mod)'
     Registers a test module to a test registry

`RCU_INT rcu_add_test_mod_tbl(RCU_TEST_REGISTRY *reg, RCU_TEST_MODULE_ENTRY *mod_tbl)'
     Registers a test module table to a test registry


File: rcunit.info,  Node: Test Function Interfaces,  Prev: Test Module Interfaces,  Up: Test Entity Interfaces

Test Function Interfaces
------------------------

   Below are the test function - related interfaces.

`RCU_INT rcu_add_test_func(RCU_TEST_MODULE *mod, RCU_GENERIC_FUNCTION entry, RCU_GENERIC_FUNCTION init,RCU_GENERIC_FUNCTION destroy, const RCU_CHAR *name,RCU_INT enable)'
     Registers a named test function entry point to a test module

`RCU_INT rcu_add_test_func_tbl(RCU_TEST_MODULE *mod, RCU_TEST_FUNCTION_ENTRY *func_tbl)'
     Registers a test function table to a test module


File: rcunit.info,  Node: Assertion Macros,  Next: Helper Macros,  Prev: Test Entity Interfaces,  Up: RCUNIT Framework Interfaces

Assertion Macros
================

   These macros are the used to assert conditions. The `cond' parameter
expects a C boolean condition (i.e. a non-zero means true, false
otherwise). The `msg' parameter expects a double-quoted string. Lastly,
the `ptr' parameter expects a pointer.

`RCU_ASSERT(cond)'
     Asserts a condition

`RCU_FAIL(msg)'
     Records an implied assertion failure described by the `msg'
     parameter

`RCU_ASSERT_TRUE(cond)'
     Asserts that the given condition must be true

`RCU_ASSERT_FALSE(cond)'
     Asserts that the given condition must be false

`RCU_ASSERT_NULL(ptr)'
     Asserts that the given pointer must be null

`RCU_ASSERT_NOT_NULL(ptr)'
     Asserts that the given pointer must not be null

`RCU_ASSERT_FATAL(cond)'
     Fatal version `RCU_ASSERT'

`RCU_FAIL_FATAL(msg)'
     Fatal version `RCU_FAIL'

`RCU_ASSERT_TRUE_FATAL(cond)'
     Fatal version of `RCU_ASSERT_TRUE'

`RCU_ASSERT_FALSE_FATAL(cond)'
     Fatal version of `RCU_ASSERT_FALSE'

`RCU_ASSERT_NULL_FATAL(ptr)'
     Fatal version of `RCU_NULL'

`RCU_ASSERT_NOT_NULL_FATAL(ptr)'
     Fatal  version of `RCU_NOT_NULL'


File: rcunit.info,  Node: Helper Macros,  Next: Error Management Interfaces,  Prev: Assertion Macros,  Up: RCUNIT Framework Interfaces

Helper Macros
=============

   These macros are used for defining test entity, test entity tables,
test run hook, and assertion hook. For uniformity and to minimize
errors in creating test codes, the user is suggested to use these
macros.

`RCU_DEF_GENERIC_FUNC(fname,param)'
     Defines a generic function entry point. All function entry point
     helper macros are implemented using this macro.

`RCU_DEF_TEST_FUNC(fname,param)'
     Defines a test function

`RCU_DEF_FUNC_TBL(tbl_name)'
     Defines a test function table start

`RCU_DEF_FUNC_TBL_END'
     Defines a test function table end

`RCU_INC_FUNC(name,func,init,destroy,enable)'
     Defines a test function table entry

`RCU_INC_FUNC_AUTONAME(func,init,destroy,enable)'
     Defines a test function tabl entry with autogenerated name

`RCU_DEF_TEST_MOD(mod)'
     Defines a test module

`RCU_DEF_MOD_TBL(mod)'
     Defines a test module table start

`RCU_DEF_MOD_TBL_END'
     Defines a test module table entry end

`RCU_INC_MOD(name,init,destroy,func_tbl,enable)'
     Defines a test module table entry

`RCU_DEF_TEST_REG(reg)'
     Defines a test registry

`RCU_DEF_INIT_FUNC(fname,param)'
     Defines an init function

`RCU_DEF_DESTROY_FUNC(fname,param)'
     Defines a destroy function

`RCU_DEF_TEST_RUN_HOOK'
     Defines a test run hook

`RCU_GET_RUN_EVT_TYPE'
     Returns the run event type `RCU_TEST_RUN_STARTED ' or
     `RCU_TEST_RUN_FINISHED' from the test run hook parameter.

`RCU_DEF_ASSERT_HOOK'
     Defines an assertion hook. This applies only to non-test run
     assertion failures

`RCU_DEF_LOG_HANDLER_IMPL(log_impl,param)'
     Defines a log handler implementation

`RCU_DEF_OUTPUT_HANDLER_IMPL(out_impl,param)'
     Defines an output handler implementation

   The following macros are used for declaring test entities or
function hooks. These are simply `extern' declarations of the variables
and is typically used if the test entities or function hooks are
defined somewhere else in the user test setup codes.

`RCU_DEC_GENERIC_FUNC(func,param)'
     Declares a generic function entry point

`RCU_DEC_TEST_FUNC(func,param)'
     Declares a test function

`RCU_DEC_TEST_FUNC_TBL(func_tbl)'
     Declares a test function table

`RCU_DEC_TEST_MOD(mod)'
     Declares a test module

`RCU_DEC_TEST_MOD_TBL(mod_tbl)'
     Declares a test module table

`RCU_DEC_TEST_REG(reg)'
     Declares a test registry

`RCU_DEC_INIT_FUNC(init_func,param)'
     Declares an init function

`RCU_DEC_DESTROY_FUNC(destroy_func,param)'
     Declares a destroy function

`RCU_DEC_TEST_RUN_HOOK(run_hook,param)'
     Declares a test run hook

`RCU_DEC_ASSERT_HOOK(assert_hook,param)'
     Declares an assertion hook

`RCU_DEF_LOG_HANDLER_IMPL(log_impl,param)'
     Declares a log handler implementation

`RCU_DEF_OUTPUT_HANDLER_IMPL(out_impl,param)'
     Declares an output handler implementation


File: rcunit.info,  Node: Error Management Interfaces,  Next: Log Management Interfaces,  Prev: Helper Macros,  Up: RCUNIT Framework Interfaces

Error Management Interfaces
===========================

   The following are the error management interfaces.

`RCU_INT rcu_get_err();'
     Returns the error code of the last operation that failed

`const RCU_CHAR* rcu_get_err_msg(RCU_INT ercd);'
     Returns the error message corresponding to an error code

   Below are the RCUNIT error codes and corresponding error strings.

`RCU_E_OK'
     "Successful"

`RCU_E_NG'
     "Failed"

`RCU_E_NOMEM'
     "Memory allocation failed"

`RCU_E_INVPARAM'
     "Invalid parameter"

`RCU_E_MACHINITDONE'
     "Machine already initialized "

`RCU_E_MACHNOINIT'
     "Machine not initialized"

`RCU_E_INVMACH'
     "Invalid machine"

`RCU_E_REGNOINIT'
     "Registry not initialized"

`RCU_E_INVREGNAME'
     "Invalid registry name"

`RCU_E_INVREG'
     "Invalid registry"

`RCU_E_INVREGTABLE'
     "Invalid registry table"

`RCU_E_UNKNOWNREG'
     "Unknown registry"

`RCU_E_REGEXISTS'
     "Registry exists"

`RCU_E_MODNOINIT'
     "Module not initialized"

`RCU_E_INVMOD'
     "Invalid module"

`RCU_E_INVMODNAME'
     "Invalid module name"

`RCU_E_INVMODTABLE'
     "Invalid module table"

`RCU_E_UNKNOWNMOD'
     "Unknown module"

`RCU_E_MODEXISTS'
     "Module exists"

`RCU_E_FUNCNOINIT'
     "Function not initialized"

`RCU_E_INVFUNCNAME'
     "Invalid function name"

`RCU_E_INVFUNC'
     "Invalid function"

`RCU_E_INVFUNCTABLE'
     "Invalid function table"

`RCU_E_FUNCEXISTS'
     "Function exists"

`RCU_E_INVFUNCENTRY'
     "Invalid function entry point"


File: rcunit.info,  Node: Log Management Interfaces,  Prev: Error Management Interfaces,  Up: RCUNIT Framework Interfaces

Log Management Interfaces
=========================

   The following are the log management interfaces.

`RCU_INT rcu_set_log_level(RCU_INT level)'
     Sets the current log level

`RCU_INT rcu_get_log_level()'
     Retrieves the current log level

`RCU_INT rcu_add_log_hnd(RCU_LOG_HANDLER *log_hnd)'
     Registers a log handler

`RCU_INT rcu_del_log_hnd(RCU_LOG_HANDLER *log_hnd)'
     Deletes a log handler

   Below are the allowed log levels.

`RCU_LOG_LEVEL_ALL'
     Enables all log message types

`RCU_LOG_LEVEL_INFO'
     Enables information, warning, and fatal log messages. This is
     functionally the same as `RCU_LOG_LEVEL_ALL'

`RCU_LOG_LEVEL_WARN'
     Enables warning and fatal log messages only

`RCU_LOG_LEVEL_FATAL'
     Enables fatal log messages only

`RCU_LOG_LEVEL_OFF'
     Disables all messages types

   The following log macros can be used anywhere in the user test
codes. The output is controlled by the current log level.

`RCU_LOG_INFO(format)'
     Logs an information message

`RCU_LOG_INFO_P1(format,p1)'
     Logs an information message with one parameter

`RCU_LOG_INFO_P2(format,p2)'
     Logs an information message with two parameters

`RCU_LOG_INFO_P3(format,p3)'
     Logs an information message with three parameters

`RCU_LOG_INFO_P4(format,p4)'
     Logs an information message with four parameters

`RCU_LOG_WARN(format)'
     Logs a warning message

`RCU_LOG_WARN_P1(format,p1)'
     Logs a warning message with one parameter

`RCU_LOG_WARN_P2(format,p2)'
     Logs a warning message with two parameters

`RCU_LOG_WARN_P3(format,p3)'
     Logs a warning message with three parameters

`RCU_LOG_WARN_P4(format,p4)'
     Logs a warning message with four parameters

`RCU_LOG_FATAL(format)'
     Logs a fatal message

`RCU_LOG_FATAL_P1(format,p1)'
     Logs a fatal message with one parameter

`RCU_LOG_FATAL_P2(format,p2)'
     Logs a fatal message with two parameters

`RCU_LOG_FATAL_P3(format,p3)'
     Logs a fatal message with three parameters

`RCU_LOG_FATAL_P4(format,p4)'
     Logs a fatal message with four parameters


File: rcunit.info,  Node: Other RCUNIT Facilities,  Next: Sample Test Codes,  Prev: RCUNIT Framework Interfaces,  Up: Top

Other RCUNIT Facilities
***********************

   The following are some useful facilities provided by the framework.

* Menu:

* Memory  Leak Check Facility :: A simple memory leak check facility
* Non-Test Run Assertions  :: Assertion statements outside test functions
* Exception Handling Mechanism::An altenative error handling mechanism


File: rcunit.info,  Node: Memory Leak Check Facility,  Next: Non-Test Run Assertions,  Up: Other RCUNIT Facilities

Memory  Leak Check Facility
===========================

   This is a simple pointer caching mechanism. Fundamentally, allocated
pointers are cached (recorded) and uncached on deallocations. The
memory allocation tracing macros can be hooked in a user-defined memory
allocation implementation or a memory allocation wrapper.  This
facility can be used independently. RCUNIT only requires the user to
invoke the framework init and destroy functions, before and after using
these macros. Below are the memory leak check macros.

``RCU_TRACE_ALLOC(ptr,size)''
     Traces the allocation of the given pointer and size

``RCU_TRACE_FREE(ptr)''
     Traces the deallocation of the given pointer

``RCU_CHECK_MEMORY_LEAK()''
     Checks the pointer cache for memory leak. This must be called in a
     code where the user assumes all allocated pointers were
     correspondingly deallocated. The memory check result is dumped
     into the RCUNIT log.

   Alternatively, the user can just use RCUNIT's internal memory
allocation routines, `rcu_malloc()', and `rcu_free()'.

   *WARNING : The facility will not work if RCU_TRACE_ALLOC is hooked
in `realloc()'* .


File: rcunit.info,  Node: Non-Test Run Assertions,  Next: Exception Handling Mechanism,  Prev: Memory Leak Check Facility,  Up: Other RCUNIT Facilities

Non-Test Run Assertions
=======================

   The assertion macros can be called in code locations other than the
test function, or init or destroy functions. Assertion failures are
recorded in separate database and can be dumped using the
`rcu_dump_asserts()' interface. Furthermore, the user can register an
assertion hook using the `rcu_set_assert()' to be able to receive
assertion failure notifications. When an assertion failure is
encountered, the framework invokes the function with a pointer to a
RCU_FAILURE_RECORD.

   Similar to most function entry points, the assertion hook is of type
RCU_GENERIC_FUNCTION. The non-test run assertion failure records are
deleted when the framework is destroyed. All non-test run assertion
failures are implicitly non-fatal.

