\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename rcunit.info
@include version.texi
@settitle RCUNIT
@setchapternewpage odd
@ifnothtml
@setcontentsaftertitlepage
@end ifnothtml
@finalout
@c %**end of header

@dircategory Testing
@direntry
* RCUNIT: (rcunit).        A robust C unit testing framework
@end direntry

@copying
This document contains information on how to use RCUNIT, a robust C unit testing framework.

This is Edition @value{EDITION}, last updated @value{UPDATED}.

Copyright (@copyright{})  2006  Jerrico L. Gamis (@email{jecklgamis@@users.sourceforge.net})

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
Texts.  A copy of the license is included in the section entitled
``GNU Free Documentation License''.
@end quotation

@end copying

@titlepage
@title RCUNIT
@subtitle A robust C unit testing framework
@author Jerrico L. Gamis
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents
@ifnottex
@node Top
@top About This Document
@insertcopying
@end ifnottex

@c The master menu
@menu
* Introduction to RCUNIT::
* Building RCUNIT::
* The RCUNIT Framework::
* RCUNIT Framework Interfaces::
* Other RCUNIT Facilities::
* Sample Test Codes::
* Sample Test Run Report::
* Sample Log File::
* Copying This Manual::
* Submitting Bugs::
* Acknowledgements::
@end menu

@node Introduction to RCUNIT
@chapter Introduction to RCUNIT

RCUNIT stands for Robust C Unit.  It is a small framework for testing C programs. Similar to other unit testing frameworks, RCUNIT is a framework used for creating repeatable tests.

@menu
* Introduction to Test Design Methods::
* Writing a Simple Repeatable Test::
@end menu

@node Introduction to Test Design Methods
@section Introduction to Test Design Methods

RCUNIT is essentially a black-box testing tool. Black box testing, also called functional or behavioral testing,  is a test method designed to test the functional requirements of a system. It has no knowledge of the internal structure of the systems as opposed to the white box testing, also called structural testing, where different execution paths are tested. While black box testing can find functional requirements misses and interface problems, white box testing can find implementation problems of the functional requirements.

RCUNIT is also a regression testing tool used for finding regression bugs. Regression bugs are consequences of program changes caused either by fixing a bug or by adding a new functionality. Creating repeatable
tests is one way of finding regression bugs.

@node Writing a Simple Repeatable Test
@section Writing a Simple Repeatable Test

Creating a repeatable test in RCUNIT is straightforward :  create a test function for the function to be tested, use one or more assertion statements inside the test function to assert conditions, register the test function to the framework, execute the test function using the framework interfaces, and view the auto-generated test run results. The example below demonstrates these procedures.

Assume we have a function that calculates the sum of two integers.
@verbatim
int calc_sum(int x, int y) {
    return(x+y);
}
@end verbatim

To test this function, we create a test function, say @code{test_calc_sum()}.

@verbatim
RCU_DEF_TEST_FUNC(test_calc_sum,param){
    RCU_ASSERT( calc_sum(-1,-1) == -2);
    RCU_ASSERT(calc_sum(0,0) == 0);
}
@end verbatim

The @code{RCU_DEF_TEST_FUNC} is an RCUNIT macro for defining a test function. The above code is the same as
@verbatim
void test_calc_sum(void *param){
    RCU_ASSERT( calc_sum(-1,-1) == -2);
    RCU_ASSERT(calc_sum(0,0) == 0);
}
@end verbatim

There are two things to note in this test function: the function prototype and the assertion statements. First, the function format of this function is a requirement of RCUNIT. All test functions must have this format. In the current functionality, the parameter is not used and is set to a null pointer when the test function is executed by the framework.  Second, the assertion statements are used to assert conditions. For instance, the first assertion statement asserts that the sum of @code{-1} and @code{-1} is @code{-2}.

Next, the test function is registered to the framework. Note that the framework must be initialized first.

@verbatim
int main(int argc,char **argv){
int ercd;

    /** Initialize framework */
    ercd = rcu_init();
    if (ercd == RCU_E_NG){
        return(-1);
    };

    /** Register the test function to the default test module. The
        function parameters are the test module, the test function
        entry point, init function, destroy function, test function
        name, and test run enable flag.
    */
    ercd = rcu_add_test_func(RCU_DEFAULT_MODULE,test_calc_sum,
        RCU_NULL, RCU_NULL,"test_calc_sum", RCU_TRUE))

    if (ercd == RCU_E_NG){
        rcu_destroy();
        return(-1);
    }

    /** Run the logical test machine */
    rcu_run_test_mach();

    /** Destroy the framework */
    rcu_destroy();

    return(0);
}
@end verbatim

Now, when the test function is executed , i.e. by executing the @code{rcu_run_test_mach()} function,  and one of the assertion statements failed, the assertion failure is recorded by the framework. After all the test functions are executed, the framework generates a test run report containing the assertion failures encountered.

Finally, assuming the  function @code{calc_sum()} is revised, the same procedures can be performed again and the test run results are rechecked. If there are no more assertion failure records, then the function is assumed to be working correctly. Of course, it is the responsibility of the user to create as many assertion statements as necessary in order to fully test the function.

Fundamentally, this is how a repeatable test is done using RCUNIT.

@node Building RCUNIT
@chapter Building RCUNIT

Using RCUNIT requires linking with the RCUNIT library. That is, RCUNIT is assumed to be tightly integrated with the user test codes. Building the RCUNIT library requires an ANSI/ISO compliant C compiler. The source codes have been compiled and tested in the following platforms.

In the Unix/Linux platform :

@itemize @bullet
@item gcc version 3.2.2 (Red Hat Linux kernel 2.4.20-8)
@item gcc version 3.3.6 (Knoppix Linux kernel 2.6.11)
@end itemize

In the Windows platform :

@itemize @bullet
@item Microsoft (@copyright{}) 32-bit C/C++ Optimizing Compiler Version 12.00.8168 for 80x86 (Windows XP)
@end itemize

@menu
* Required C Library Functions and Macros::
* Configuration Flags::
@end menu

@node Required C Library Functions and Macros
@section Required C Library Functions and Macros

RCUNIT uses the following C library functions.

@itemize
String functions : @code{strcpy}, @code{strlen} @code{strcmp} @*
Memory functions : @code{malloc}, @code{free}, @code{memset}, @code{memcpy} @*
Printing functions : @code{fprintf} , @code{sprintf} @*
Non-local jump functions : @code{setjmp}, @code{longjmp} @*
Time functions: @code{time}, @code{ctime}
@end itemize

RCUNIT also uses the following pre-defined ANSI/ISO C macros.

@itemize
@code{__FILE__},
@code{__LINE__},
@code{__DATE__},
@code{__TIME__}
@end itemize

@node Configuration Flags
@section Configuration Flags

The file @file{rcunit_config.h} contains the RCUNIT configuration switches. RCUNIT also uses another configuration file @file{rcunit_config_env.h} that contains preprocessor symbols corresponding to the probed features of the platform (e.g. C library functions ) and other information such as version numbers. In the Unix/Linux build, this file is automatically created in the configuration process (i.e. invocation of the @file{configure} script). In other platforms where the @file{configure} script cannot be used, the bundled configuration header file must be edited manually. @file{rcunit_config_env.h} is included by the main configuration header file @file{rcunit_config}.

@table @code
@item RCU_DEBUG
This symbol must be defined to enable debug mode. In the Unix/Linux build, this macro is automatically defined if the @code{--enable-debug=yes} option is given in the invocation of @code{configure} script. In Windows and other platforms, the symbol can be defined using the -D option of the compiler.
@end table

The following preprocessor symbols are defined inside @code{rcu_config.h}. These are enabled by setting a non-zero value.

@table @code
@item RCU_ENABLE_ANSI_FILE_IO
    If set, tells RCUNIT that an ANSI file I/O is available. This is enabled by default.
@item RCU_ENABLE_MALLOC_ALIGNMENT
    Enables memory allocation alignment. All internal memory allocations used by RCUNIT are aligned to the native integer size (sizeof(int)).
This is enabled by default.
@item RCU_ENABLE_MTRACE
    Enables memory leak check facility. This is enabled by default.
@item RCU_ENABLE_EMIT_PLAINTEXT_LOG
    Enables plain text log file instead of HTML. This is disabled by default.
@item RCU_ENABLE_EMIT_PLAINTEXT_REPORT
    Enables plain text test run report file instead of HTML. This is disabled by default.
@end table

If @code{RCU_ENABLE_ANSI_FILE_IO} is disabled, @code{RCU_ENABLE_EMIT_PLAINTEXT_LOG} and @code{RCU_ENABLE_EMIT_PLAINTEXT_REPORT} are always enabled by the framework.

@node The RCUNIT Framework
@chapter The RCUNIT Framework

The chapter contains information on the RCUNIT framework entities and operations.

@menu
* Data Types:: RCUNIT-defined data types
* Test Entities:: Logical entities for structuring tests
* Test Entity Operations:: Operations for structuring and running tests
* The Test Machine:: Logical entity that executes the tests
* Error Management:: Error handling in RCUNIT
* Log Management:: Log handling in RCUNIT
* Output Mechanism:: RCUNIT's output redirection mechanism
@end menu

@node Data Types
@section Data Types

The following are the commonly used RCUNIT data types.

@table @code
@item RCU_INT
    Integer data type
@item RCU_CHAR
    Character data type
@item RCU_VOID
    Void data type
@item RCU_GENERIC_FUNCTION
    This is the format of all the function entry points used inside the framework.  This applies to test function, test function init and destroy functions, test module init and destroy functions, test run hook, assertion hook, log handler, and output handler.  The RCU_GENERIC_FUNCTION has the definition @code{typedef void(*RCU_GENERIC_FUNCTION)(void *)}. That is, all the function entry points have the form @code{void test_xxx(void *param)}.

@item RCU_TEST_FUNCTION
    Test function data type
@item RCU_TEST_FUNCTION_ENTRY
    Test function table entry data type
@item RCU_TEST_MODULE
    Test module data type
@item RCU_TEST_MODULE_ENTRY
    Test module table entry data type
@item RCU_TEST_REGISTRY
    Test registry data type
@item RCU_OUTPUT_RECORD
    Output record data type

@item RCU_LOG_HANDLER
    Log handler data type
@verbatim
/** @brief Log handler data structure */
typedef struct rcu_log_handler{
RCU_GENERIC_LIST link;              /**< Link to other handlers (Used by the framework) */
RCU_GENERIC_FUNCTION init;          /**< Initialization function */
RCU_GENERIC_FUNCTION destroy;       /**< Destruction function */
RCU_GENERIC_FUNCTION log_impl;      /**< Log implementation */
}RCU_LOG_HANDLER;
@end verbatim

@item RCU_LOG_RECORD
    Log record data type
@verbatim
/** @brief Log record */
typedef struct rcu_log_record {
RCU_INT level;                      /**< Log level */
RCU_CHAR *data;                     /**< Log data */
}RCU_LOG_RECORD;
@end verbatim

@item RCU_OUTPUT_HANDLER
    Output handler data type
@verbatim
/** @brief Output handler data structure */
typedef struct rcu_output_handler{
RCU_GENERIC_LIST link;              /**< Link to other handlers (Used by the framework) */
RCU_GENERIC_FUNCTION init;          /**< Initialization function */
RCU_GENERIC_FUNCTION destroy;       /**< Destruction function */
RCU_GENERIC_FUNCTION out_impl;      /**< Output implementation */
}RCU_OUTPUT_HANDLER;
@end verbatim

@item RCU_OUTPUT_RECORD
    Output record
@verbatim
/** @brief Output record */
typedef struct rcu_output_record {
RCU_VOID *data;                     /**< Output data */
}RCU_OUTPUT_RECORD;
@end verbatim

@item RCU_FAILURE_RECORD
    Assertion failure record data type
@verbatim
/**  @brief  Failure record entry */
typedef struct rcu_failure_record {
RCU_GENERIC_LIST link;              /**< Link to the next/previous record */
RCU_CHAR *info;                     /**< Information */
}RCU_FAILURE_RECORD;
@end verbatim

@end table

The following are the commonly used symbols.
@table @code
@item RCU_FALSE,RCU_TRUE
    Boolean definitions
@item RCU_NULL
    Null pointer reference
@item RCU_DEFAULT_REGISTRY
    Refers to the default test registry
@item RCU_DEFAULT_MODULE
    Refers to the default test module
@end table

When defining or declaring function entry points, the user is suggested to use the helper macros. @xref{Helper Macros}.

@node Test Entities
@section  Test Entities

The following are the RCUNIT test entities.

@menu
* Test Function:: The test workarea
* Test Module:: Groups one or more test functions
* Test Registry:: Groups one or more test modules
* The Default Test Registry and Test module::
@end menu

@node Test Function
@subsection Test Function

A test function is a work area for testing a particular C function.  Inside this function, the user calls assertion statements to assert  specific conditions. The condition depends on the results of operations performed on the C function being tested. For example it can be an assertion of the function's return value or output parameter value. Failed assertion conditions are recorded and collected after all the test functions have been executed.

A test function is identified by a user-defined or framework-defined name and function entry point address (i.e. the name of the function entry point itself). It can have optional initialization (init) and destruction (destroy) functions, which are executed before and after the main test function, respectively. A test function must be registered to at most one test module and it can be registered as disabled or enabled. A disabled test function is not executed during a test run.

A group of test functions can be collectively registered to a test module. The test functions are grouped in a table, called the test function table, before they are added to a particular test module.

The sample code below shows how to define a test function, an init function or  destroy function, and a test function table.

@b{Test function:}
@verbatim
RCU_DEF_TEST_FUNC(test_xxx,param){
}
@end verbatim

@b{Init function:}
@verbatim
RCU_DEF_INIT_FUNC(test_xxx_init,param){
}
@end verbatim

@b{Destroy function:}
@verbatim
RCU_DEF_DESTROY_FUNC(test_xxx_destroy,param){
}
@end verbatim

The @code{param} is an implicit pointer to a void data type (RCU_VOID*). When the framework invokes these function entry points, the param is just set to RCU_NULL. The actual parameter names are user-defined.

@b{Test function table :}
@verbatim
RCU_DEF_FUNC_TBL(xxx_func_tbl)
    RCU_INC_FUNC_ENTRY_AUTONAME(test_xxx,test_xxx_init,test_xxx_destroy,RCU_TRUE)
          or
    RCU_INC_FUNC_ENTRY("test_xxx",test_xxx,test_xxx_init,test_xxx_destroy,RCU_TRUE)
    ...
RCU_DEF_FUNC_TBL_END
@end verbatim

The @code{RCU_INC_FUNC_ENTRY_AUTONAME} macro automatically generates the test function's name from the actual function name. To use a user-defined one, simply use the @code{RCU_INC_FUNC_ENTRY} macro.

@xref{Helper Macros}.

@node Test Module
@subsection Test Module

A test module holds one or more test functions. In other test frameworks, this is also called a test suite. A test module can be a user-defined module or the default test module provided by the framework.

A test module is identified by a name, can have optional init and destroy functions that are executed before and after completion of all test functions, and must be registered to at most one test registry. Similar to a test function, a test module can be created as disabled or enabled.

A group of test modules can be collectively registered to a test registry.  The modules are grouped in a table called test module table, before they are added to a particular test registry.

The sample code below shows how to define a test module, an init function, a destroy function, and a test module table

@b{Test module:}
@verbatim
RCU_DEF_TEST_MOD(mod_xxx)
@end verbatim

@b{Init function:}
@verbatim
RCU_DEF_INIT_FUNC(mod_xxx_init,param){
}
@end verbatim

@b{Destroy function:}
@verbatim
RCU_DEF_DESTROY_FUNC(mod_xxx_destroy,param){
}
@end verbatim

@b{Test module table:}
@verbatim
RCU_DEF_MOD_TBL(xxx_mod_tbl)
    RCU_INC_MOD("m1",RCU_NULL,RCU_NULL,xxx_func_tbl_1,RCU_TRUE);
    RCU_INC_MOD("m2",RCU_NULL,RCU_NULL,xxx_func_tbl_2,RCU_FALSE);
RCU_DEF_MOD_TBL_END
@end verbatim

The macro @code{RCU_DEF_TEST_MOD} is used only when a test module is is not part of a test module table. Otherwise, only the test module name is required in the test module table entry. In the sample test module table, a test module named "m1" is defined with no init or destroy function and is registered as enabled. The next entry is for a test module named "m2" with no init or destroy function, and is registered as disabled.

@xref{Helper Macros}.

@node Test Registry
@subsection Test Registry

A test registry provides another level of hierarchy. It holds one or more test modules. A test registry can be a user-defined registry or the default test registry provided by the framework.

A test registry is identified by a name, can be created as disabled or enabled, but does not have init or destroy functions. A test registry can be registered to the test machine only once.

The sample code below shows how to define a test registry

@verbatim
RCU_DEF_TEST_REG(reg_xxx)
@end verbatim

@node The Default Test Registry and Test module
@subsection The Default Test Registry and Test module

Upon initialization of the framework, the default test registry and  test module are automatically created. The default test module is automatically registered to the default test registry. The default test registry is named as  "default-reg". This name cannot be used by user-defined test registries. The test registry can be referenced using a null name or reference (For uniformity, the RCUNIT-defined macro @code{RCU_DEFAULT_REGISTRY} can be used).

The test module is named "default-mod". This name cannot be used in user-defined test module. Similar to the default test registry, it can be also referenced using a null name or reference. (For uniformity, the RCUNIT-defined macro @code{RCU_DEFAULT_MODULE} can be used).

The default test registry and test module are automatically destroyed, including all the entities registered entities, when the test machine is destroyed.

@node Test Entity Operations
@section Test Entity Operations

The following are the operations on the test entities.

@menu
* Test Entity Creation and Registration::
* Test Entity Destruction::
* Test Entity Execution::
* Test Entity Database Dumping::
@end menu

@node Test Entity Creation and Registration
@subsection Test Entity Creation and Registration

Before a test function can be registered to a test module, the test module must be created and registered first into a test registry. Furthermore, the test registry must be created and registered first to the test machine. In short, a higher level test entity must be created and registered first before any lower level test entity can be registered. The entity registration process can be summarized as:

@enumerate
@item Creating a test registry
@item Registering the test registry to the test machine
@item Creating a test module or test module table
@item Registering the test module  or test module table
@item Registering a test function or test function table
@end enumerate

If the default test registry or test module is to be used, the creation and registration steps are no longer necessary.

@xref{Test Entity Interfaces}.

@node Test Entity Destruction
@subsection Test Entity Destruction

When test entities are already registered to the test machine, destroying the test machine will destroy all of the entities. That is, all test entity references will be invalidated. If a particular test entity is not yet registered (i.e. not known by the test machine), then the user must manually destroy it using the interface functions provided. Failure to do so will result in a memory leak.

@xref{Test Entity Interfaces}.

@node Test Entity Execution
@subsection Test Entity Execution

The test execution, also called a test run, is the process of executing test entities. All registered test entities in the test entity database are executed if the entities are registered as "enabled". The @code{rcu_run_test_mach()} function is used to start a test run.

The user can optionally set a test run callback function (also called a test run hook). A test run callback function is invoked at the start and at the end of a test run. The sample code below shows how to define a test run hook.

@verbatim
RCU_DEF_TEST_RUN_HOOK(xxx_run_hook,param){
RCU_INT run_event;

    run_event = RCU_GET_RUN_EVT_TYPE(param);

    if (run_event == RCU_TEST_RUN_STARTED){

        /** code for test run start event */

   }else if (run_event == RCU_TEST_RUN_FINISHED){

       /** code for test run end event */

   }
@end verbatim

The test run hook function can be setup using the @code{rcu_set_run_hook()} interface.

@xref{Test Entity Interfaces}.

@xref{Helper Macros}.

@node Test Entity Database Dumping
@subsection Test Entity Database Dumping

RCUNIT provides an interface for dumping the test entity database. This is useful for verifying the layout of the test entities. The test entity database is dumped into the RCUNIT log.

@xref{Test Entity Interfaces}.

@node The Test Machine
@section The Test Machine

The test machine is a  logical entity that executes the tests. It is initialized on framework initialization and is destroyed on framework destruction. Furthermore, all RCUNIT interfaces can be used only after the framework has been initialized.

@menu
* Test Entity Database:: Holds the test entities
* Assertion Engine::Records assertion failures
* Test Run Report Generator::Generates test run report
@end menu

@node Test Entity Database
@subsection Test Entity Database

The test entity database is the main placeholder of all the test entities.  All the test entities (functions, modules, and registries) must be registered to the test database before before it can be executed.

Below is the runtime layout of the test entity database.

@verbatim
Test Entity Database
    + Default registry
    |   + Default module
    |       +- Test Function A-1
    |       +- Test Function A-2
    |       +- ...
    |       +- Test Function A-N
    +- Test registry 1
    |    +- Test Module 1
    |    |  +- Test Function B-1
    |    |  +- Test Function B-2
    |    |  +- ...
    |    |  +- Test Function B-N
    |   +- Test Module 2
    |   +- ...
    |   +- Test Module N
    +- Test registry 2
    +- ...
    +- Test registry N
@end verbatim

@node Assertion Engine
@subsection Assertion Engine

The assertion engine is a logical processing inside the test machine. Its primary function is to record all the assertion failures encountered during a test run. The assertion engine relies on the exception mechanism which handles the abortion of a currently executing test function when a fatal assertion failure is encountered.

The assertion statements are the interface between the user test code and the assertion engine. An assertion statement can be a fatal or non-fatal one. An assertion statement that failed is recorded by the assertion engine. Furthermore, a fatal assertion failure aborts a currently executing code.

Assertion statements can be called in any of following code locations. The behavior during an assertion failure is also described.

@itemize @bullet
@item Test function - An assertion failure is recorded and the test function result is set as "Failed". A fatal assertion failure aborts execution of this function.

@item Test function init function - An assertion failure is recorded. A fatal or a non-fatal assertion failure aborts execution of this function. The test function is no longer executed and the result is set as "Aborted". Note that this is an implied failure.

@item Test function destroy function - An assertion failure is recorded. The test function result is set as "Failed" even if there are no assertion failures encountered in the test function itself.

@item  Test module init function - An assertion failure is recorded. A fatal or a non-fatal assertion failure aborts execution of this function. The test functions, and corresponding init or destroy functions if set, are no longer executed.

@item  Test module destroy function - An assertion failure is recorded.
@end itemize

Assertions failures encountered from other code locations are considered non-test run assertions. @xref{Non-Test Run Assertions}.

@node Test Run Report Generator
@subsection Test Run Report Generator

The test run report generator collects the test run results and generates a test run report after a test run. The report contains the following information.

@emph{Test run summary}

@itemize @bullet
@item Total number of registered test registries
@item Number of completed test registries (classified as Passed or Failed)
@item Total number of registered test modules
@item Number of completed test modules  (classified as Passed, Failed, or Aborted)
@item Total number of registered test functions
@item Number of completed test functions (classified as either Passed,  Failed, or Aborted).
@item Total number of assertions found (classified as Passed, Failed (non-fatal), or Failed (fatal))
@end itemize

@emph{Per test registry run statistics}

@itemize @bullet
@item Total number of registered test modules
@item Number of completed test modules
@item Number of passed test modules
@item Number of failed test modules
@end itemize

@emph{Per test module run statistics}

@itemize @bullet
@item Total number of registered test functions
@item Number of completed test functions
@item Number of passed test functions
@item Number of failed test functions
@item Number of aborted test functions
@end itemize

@emph{Per test function run statistics}

@itemize @bullet
@item Test result status ("Passed", "Failed", "Aborted", "Disabled")
@item Total number of assertions found
@item Total number of failed assertions
@item List of failure records in the following format
@end itemize

For non-fatal assertion failures : @*
@code{<source file name>(<line number>) : fail : <condition or message>}

For fatal assertion failures : @*
@code{<source file name>(<line number>) : fatal : <condition or message>}

@menu
* Definition of "Failed" Result::
* Test Run Reporting::
@end menu

@node Definition of "Failed" Result
@subsubsection Definition of "Failed" Result

@itemize @bullet
@item A test registry is considered "Failed" if one of the registered test modules failed
@item A test module is considered "Failed" if one of the registered test functions or the module's init function failed
@item A test function is considered "Failed" if there is an asseertion failure encountered or the test function's init function failed
@end itemize

@node Test Run Reporting
@subsubsection Test Run Reporting

If an ANSI file I/O facility is available, RCUNIT generates an HTML test run report (@file{rcunit_test_run_report.html}) or a plaintext test run report (@file{rcunit_test_run_report.txt}) if the framework is recompiled with @code{RCU_ENABLE_EMIT_PLAINTEXT_REPORT} enabled. However if an ANSI I/O facility is not available, the report is is directed using RCUNIT's output redirection mechanism. Furthermore, the redirected report is in plain text format. @xref{Output Mechanism}.
@node Error Management
@section Error Management

RCUNIT uses simplified error handling. All RCUNIT interfaces return only two possible values : a successful operation code or a failure operation code. For integer return types, the return is either an RCU_E_OK or RCU_E_NG. For pointer return types, the return is either a null or a non-null pointer. The specific error code and error string can be retrieved using the error management interfaces.

The framework cannot catch run time system exception such as an invalid memory reference. The integrity of the test run report cannot be guaranteed in such situation.

@xref{Error Management Interfaces}.

@node Log Management
@section Log Management

In a typical test run  the user is concerned mainly with the test run report. However, if there are failures in the internal processing, such as a memory allocation failure, the user can check the log file for the details of the error. If an ANSI file I/O facility is available, the  framework generates an HTML file or a plain text file if the framework is recompiled with @code{RCU_ENABLE_EMIT_PLAINTEXT_LOG} enabled. On the other hand, if an ANSI file I/O facility is not available, the logs are redirected to the framework's output redirection mechanism. @xref{Output Mechanism}. Redirected logs are in plain text format.

RCUNIT differentiates a log message as information, warning, or a fatal log. The framework provides interfaces for setting and getting the current log level. The setting can be one of the following

@itemize @bullet
@item Logging is turned off
@item Logger emits all log message types
@item Logger emits fatal log messages only
@item Logger emits warning and fatal messages only
@end itemize

@b{Log Handlers}

RCUNIT uses log handlers to implement actual logging. Using log handlers, the user can redirect log data to a specific device or  interface. An example is serial log handler, an IDE's debug output window log handler, or a socket-based log handler. If an ANSI file I/O facility is available, the framework provides a default file log handler and a standard output @code{stdout} log handlers.

The sample code below shows how to setup a log handler.

@verbatim
RCU_LOG_HANDLER xxx_log_hnd;

RCU_DEF_INIT_FUNC(xxx_log_hnd_init,param){
    /** Code to init log handler */
}

RCU_DEF_DESTROY_FUNC(xxx_log_hnd_destroy,param){
    /** Code to destroy log handler */
}

RCU_DEF_LOG_HANDLER_IMPL(xxx_log_hnd_log_impl,param){
RCU_LOG_RECORD *log_rec;
    out_rec = (RCU_LOG_RECORD*)param;
    /** Code to implement the actual log */
}

void setup_log_handler(){

    /** Setup callback functions */
    xxx_log_hnd.init = xxx_log_hnd_init;
    xxx_log_hnd.destroy = xxx_log_hnd_destroy;
    xxx_log_hnd.out_impl = xxx_log_hnd_out_impl;

    /** Register the log handler */
    rcu_add_log_hnd(&log_hnd);
    ...
    /** Remove the log handler */
    rcu_del_log_hnd(&log_hnd);

}
@end verbatim

To be able to immediately receive logs, the log handler must be registered right after framework initialization.

@xref{Log Management Interfaces}.

@node Output Mechanism
@section Output Mechanism

If an ANSI file I/O facility is available (@code{ RCU_ENABLE_ANSI_FILE_IO} is enabled in file @file{rcu_config}) in the system, RCUNIT uses it to create the log file and the test run report. Otherwise, RCUNIT uses an output redirection mechanism in the form of callback mechanism. Essentially, it is the user that must provide the actual implementation of the output by implementing required callback functions. These callback functions are collectively called as output handler.

The sample code below shows how to setup an output handler.

@verbatim
RCU_OUTPUT_HANDLER xxx_out_hnd;

RCU_DEF_INIT_FUNC(xxx_out_hnd_init,param){
    /** Code to initialize output handler */
}

RCU_DEF_DESTROY_FUNC(xxx_out_hnd_destroy,param){
    /** Code to destroy output handler */
}

RCU_DEF_OUT_HANDLER_IMPL(xxx_out_hnd_out_impl,param){
RCU_OUTPUT_RECORD *out_rec;
    out_rec = (RCU_OUTPUT_RECORD*)param;
    /** Code to implement the actual output */
}

void setup_output_handler(){

    /** Setup callback functions */
    xxx_out_hnd.init = xxx_out_hnd_init;
    xxx_out_hnd.destroy = xxx_out_hnd_destroy;
    xxx_out_hnd.out_impl = xxx_out_hnd_out_impl;

    /** Register the output handler */
    rcu_add_out_hnd(&out_hnd);
    ...
    /** Remove the output handler */
    rcu_del_out_hnd(&out_hnd);

}
@end verbatim

@node RCUNIT Framework Interfaces
@chapter RCUNIT Framework Interfaces

This chapter provides summary information on the RCUNIT interfaces. See the separate source code documentation for the details of each interface.

@menu
* The RCUNIT Header and Library File::
* The Main Framework Interfaces::
* Test Entity Interfaces::
* Assertion Macros::
* Helper Macros::
* Error Management Interfaces::
* Log Management Interfaces::
@end menu

@node The RCUNIT Header and Library File
@section The RCUNIT Header and Library File

All the RCUNIT data types, definitions, interface function prototypes,  etc.  are defined directly  or indirectly inside @file{rcunit.h} header file. The user must include this file to be able to use the framework. Furthermore, the test codes must be linked with the RCUNIT library.


@node The Main Framework Interfaces
@section The Main Framework Interfaces

Below are the main framework interfaces.

@table @code
@item RCU_INT rcu_init()
    Initializes the framework
@item RCU_INT rcu_destroy()
    Destroys the framework.
@item RCU_INT rcu_run_test_mach()
    Runs the test machine
@item RCU_INT rcu_dump_test_dbase()
    Dumps the test entity database
@item RCU_INT rcu_set_run_hook(RCU_GENERIC_FUNCTION run_hook)
    Registers a test run callback function
@item RCU_INT rcu_set_assert_hook(RCU_GENERIC_FUNCTION assert_hook)
    Sets a non - test run assertion hook
@item RCU_INT rcu_dump_asserts()
    Dumps non - test run assertions found
@end table

@node Test Entity Interfaces
@section Test Entity Interfaces

@menu
* Test Registry Interfaces::
* Test Module Interfaces::
* Test Function Interfaces::
@end menu

@node Test Registry Interfaces
@subsection Test Registry Interfaces

Below are the test registry - related interfaces.

@table @code
@item RCU_TEST_REGISTRY *rcu_cre_test_reg(const RCU_CHAR *name, RCU_INT enable)
    Creates a test registry
@item RCU_INT rcu_destroy_test_reg(RCU_TEST_REGISTRY *reg)
    Destroys a test registry
@item RCU_INT rcu_add_test_reg(RCU_TEST_REGISTRY *reg)
    Registers a test registry to the test machine
@end table

@node Test Module Interfaces
@subsection Test Module Interfaces

Below are the test module - related interfaces.

@table @code
@item RCU_TEST_MODULE *rcu_cre_test_mod(const char *name, RCU_GENERIC_FUNCTION RCU_INT, RCU_GENERIC_FUNCTION destroy, RCU_INT enable)
    Creates a test module
@item int rcu_destroy_test_mod(RCU_TEST_MODULE *mod)
    Destroys a test module
@item RCU_INT rcu_add_test_mod(RCU_TEST_REGISTRY *reg, RCU_TEST_MODULE *mod)
    Registers a test module to a test registry
@item RCU_INT rcu_add_test_mod_tbl(RCU_TEST_REGISTRY *reg, RCU_TEST_MODULE_ENTRY *mod_tbl)
    Registers a test module table to a test registry
@end table

@node Test Function Interfaces
@subsection Test Function Interfaces

Below are the test function - related interfaces.

@table @code
@item RCU_INT rcu_add_test_func(RCU_TEST_MODULE *mod, RCU_GENERIC_FUNCTION entry, RCU_GENERIC_FUNCTION init,RCU_GENERIC_FUNCTION destroy, const RCU_CHAR *name,RCU_INT enable)
    Registers a named test function entry point to a test module
@item  RCU_INT rcu_add_test_func_tbl(RCU_TEST_MODULE *mod, RCU_TEST_FUNCTION_ENTRY *func_tbl)
    Registers a test function table to a test module
@end table

@node Assertion Macros
@section Assertion Macros

These macros are the used to assert conditions. The @code{cond} parameter expects a C boolean condition (i.e. a non-zero means true, false otherwise). The @code{msg} parameter expects a double-quoted string. Lastly, the @code{ptr} parameter expects a pointer.

@table @code
@item RCU_ASSERT(cond)
    Asserts a condition
@item RCU_FAIL(msg)
    Records an implied assertion failure described by the @code{msg} parameter
@item RCU_ASSERT_TRUE(cond)
    Asserts that the given condition must be true
@item RCU_ASSERT_FALSE(cond)
    Asserts that the given condition must be false
@item RCU_ASSERT_NULL(ptr)
    Asserts that the given pointer must be null
@item RCU_ASSERT_NOT_NULL(ptr)
    Asserts that the given pointer must not be null
@item RCU_ASSERT_FATAL(cond)
    Fatal version @code{RCU_ASSERT}
@item RCU_FAIL_FATAL(msg)
    Fatal version @code{RCU_FAIL}
@item RCU_ASSERT_TRUE_FATAL(cond)
    Fatal version of @code{RCU_ASSERT_TRUE}
@item RCU_ASSERT_FALSE_FATAL(cond)
    Fatal version of @code{RCU_ASSERT_FALSE}
@item RCU_ASSERT_NULL_FATAL(ptr)
    Fatal version of @code{RCU_NULL}
@item RCU_ASSERT_NOT_NULL_FATAL(ptr)
    Fatal  version of @code{RCU_NOT_NULL}
@end table

@node Helper Macros
@section Helper Macros

These macros are used for defining test entity, test entity tables, test run hook, and assertion hook. For uniformity and to minimize errors in creating test codes, the user is suggested to use these macros.

@table @code
@item RCU_DEF_GENERIC_FUNC(fname,param)
    Defines a generic function entry point. All function entry point helper macros are implemented using this macro.
@item RCU_DEF_TEST_FUNC(fname,param)
    Defines a test function
@item RCU_DEF_FUNC_TBL(tbl_name)
    Defines a test function table start
@item RCU_DEF_FUNC_TBL_END
    Defines a test function table end
@item RCU_INC_FUNC(name,func,init,destroy,enable)
    Defines a test function table entry
@item RCU_INC_FUNC_AUTONAME(func,init,destroy,enable)
    Defines a test function tabl entry with autogenerated name
@item RCU_DEF_TEST_MOD(mod)
    Defines a test module
@item RCU_DEF_MOD_TBL(mod)
    Defines a test module table start
@item RCU_DEF_MOD_TBL_END
    Defines a test module table entry end
@item RCU_INC_MOD(name,init,destroy,func_tbl,enable)
    Defines a test module table entry
@item RCU_DEF_TEST_REG(reg)
    Defines a test registry
@item RCU_DEF_INIT_FUNC(fname,param)
    Defines an init function
@item RCU_DEF_DESTROY_FUNC(fname,param)
    Defines a destroy function
@item RCU_DEF_TEST_RUN_HOOK
    Defines a test run hook
@item RCU_GET_RUN_EVT_TYPE
    Returns the run event type @code{RCU_TEST_RUN_STARTED
} or @code{RCU_TEST_RUN_FINISHED} from the test run hook parameter.
@item RCU_DEF_ASSERT_HOOK
    Defines an assertion hook. This applies only to non-test run assertion failures
@item RCU_DEF_LOG_HANDLER_IMPL(log_impl,param)
    Defines a log handler implementation
@item RCU_DEF_OUTPUT_HANDLER_IMPL(out_impl,param)
    Defines an output handler implementation
@end table

The following macros are used for declaring test entities or function hooks. These are simply @code{extern} declarations of the variables and is typically used if the test entities or function hooks are defined somewhere else in the user test setup codes.

@table @code
@item RCU_DEC_GENERIC_FUNC(func,param)
    Declares a generic function entry point
@item RCU_DEC_TEST_FUNC(func,param)
    Declares a test function
@item RCU_DEC_TEST_FUNC_TBL(func_tbl)
    Declares a test function table
@item RCU_DEC_TEST_MOD(mod)
    Declares a test module
@item RCU_DEC_TEST_MOD_TBL(mod_tbl)
    Declares a test module table
@item RCU_DEC_TEST_REG(reg)
    Declares a test registry
@item RCU_DEC_INIT_FUNC(init_func,param)
    Declares an init function
@item RCU_DEC_DESTROY_FUNC(destroy_func,param)
    Declares a destroy function
@item RCU_DEC_TEST_RUN_HOOK(run_hook,param)
    Declares a test run hook
@item RCU_DEC_ASSERT_HOOK(assert_hook,param)
    Declares an assertion hook
@item RCU_DEF_LOG_HANDLER_IMPL(log_impl,param)
    Declares a log handler implementation
@item RCU_DEF_OUTPUT_HANDLER_IMPL(out_impl,param)
    Declares an output handler implementation
@end table

@node Error Management Interfaces
@section Error Management Interfaces

The following are the error management interfaces.

@table @code
@item RCU_INT rcu_get_err();
    Returns the error code of the last operation that failed
@item const RCU_CHAR* rcu_get_err_msg(RCU_INT ercd);
    Returns the error message corresponding to an error code
@end table

Below are the RCUNIT error codes and corresponding error strings.

@table @code
@item RCU_E_OK
    "Successful"
@item RCU_E_NG
    "Failed"
@item RCU_E_NOMEM
    "Memory allocation failed"
@item RCU_E_INVPARAM
    "Invalid parameter"
@item RCU_E_MACHINITDONE
    "Machine already initialized "
@item RCU_E_MACHNOINIT
    "Machine not initialized"
@item RCU_E_INVMACH
    "Invalid machine"
@item RCU_E_REGNOINIT
    "Registry not initialized"
@item RCU_E_INVREGNAME
    "Invalid registry name"
@item RCU_E_INVREG
    "Invalid registry"
@item RCU_E_INVREGTABLE
    "Invalid registry table"
@item RCU_E_UNKNOWNREG
    "Unknown registry"
@item RCU_E_REGEXISTS
    "Registry exists"
@item RCU_E_MODNOINIT
    "Module not initialized"
@item RCU_E_INVMOD
    "Invalid module"
@item RCU_E_INVMODNAME
    "Invalid module name"
@item RCU_E_INVMODTABLE
    "Invalid module table"
@item RCU_E_UNKNOWNMOD
    "Unknown module"
@item RCU_E_MODEXISTS
    "Module exists"
@item RCU_E_FUNCNOINIT
    "Function not initialized"
@item RCU_E_INVFUNCNAME
    "Invalid function name"
@item RCU_E_INVFUNC
    "Invalid function"
@item RCU_E_INVFUNCTABLE
    "Invalid function table"
@item RCU_E_FUNCEXISTS
    "Function exists"
@item RCU_E_INVFUNCENTRY
    "Invalid function entry point"
@end table

@node Log Management Interfaces
@section  Log Management Interfaces

The following are the log management interfaces.

@table @code
@item RCU_INT rcu_set_log_level(RCU_INT level)
    Sets the current log level
@item RCU_INT rcu_get_log_level()
    Retrieves the current log level
@item RCU_INT rcu_add_log_hnd(RCU_LOG_HANDLER *log_hnd)
    Registers a log handler
@item RCU_INT rcu_del_log_hnd(RCU_LOG_HANDLER *log_hnd)
    Deletes a log handler
@end table

Below are the allowed log levels.

@table @code
@item RCU_LOG_LEVEL_ALL
    Enables all log message types
@item RCU_LOG_LEVEL_INFO
    Enables information, warning, and fatal log messages. This is functionally the same as @code{RCU_LOG_LEVEL_ALL}
@item RCU_LOG_LEVEL_WARN
    Enables warning and fatal log messages only
@item RCU_LOG_LEVEL_FATAL
    Enables fatal log messages only
@item RCU_LOG_LEVEL_OFF
    Disables all messages types
@end table

The following log macros can be used anywhere in the user test codes. The output is controlled by the current log level.

@table @code
@item RCU_LOG_INFO(format)
    Logs an information message
@item RCU_LOG_INFO_P1(format,p1)
    Logs an information message with one parameter
@item RCU_LOG_INFO_P2(format,p2)
    Logs an information message with two parameters
@item RCU_LOG_INFO_P3(format,p3)
    Logs an information message with three parameters
@item RCU_LOG_INFO_P4(format,p4)
    Logs an information message with four parameters
@item RCU_LOG_WARN(format)
    Logs a warning message
@item RCU_LOG_WARN_P1(format,p1)
    Logs a warning message with one parameter
@item RCU_LOG_WARN_P2(format,p2)
    Logs a warning message with two parameters
@item RCU_LOG_WARN_P3(format,p3)
    Logs a warning message with three parameters
@item RCU_LOG_WARN_P4(format,p4)
    Logs a warning message with four parameters
@item RCU_LOG_FATAL(format)
    Logs a fatal message
@item RCU_LOG_FATAL_P1(format,p1)
    Logs a fatal message with one parameter
@item RCU_LOG_FATAL_P2(format,p2)
    Logs a fatal message with two parameters
@item RCU_LOG_FATAL_P3(format,p3)
    Logs a fatal message with three parameters
@item RCU_LOG_FATAL_P4(format,p4)
    Logs a fatal message with four parameters
@end table

@node Other RCUNIT Facilities
@chapter Other RCUNIT Facilities

The following are some useful facilities provided by the framework.

@menu
* Memory  Leak Check Facility :: A simple memory leak check facility
* Non-Test Run Assertions  :: Assertion statements outside test functions
* Exception Handling Mechanism::An altenative error handling mechanism
@end menu

@node Memory  Leak Check Facility
@section Memory  Leak Check Facility

This is a simple pointer caching mechanism. Fundamentally, allocated pointers are cached (recorded) and uncached on deallocations. The memory allocation tracing macros can be hooked in a user-defined memory allocation implementation or a memory allocation wrapper.  This facility can be used independently. RCUNIT only requires the user to invoke the framework init and destroy functions, before and after using these macros. Below are the memory leak check macros.

@table @code
@item @code{RCU_TRACE_ALLOC(ptr,size)}
    Traces the allocation of the given pointer and size
@item @code{RCU_TRACE_FREE(ptr)}
    Traces the deallocation of the given pointer
@item @code{RCU_CHECK_MEMORY_LEAK()}
    Checks the pointer cache for memory leak. This must be called in a code where the user assumes all allocated pointers were correspondingly deallocated. The memory check result is dumped into the RCUNIT log.
@end table

Alternatively, the user can just use RCUNIT's internal memory allocation routines, @code{rcu_malloc()}, and @code{rcu_free()}.

@strong{WARNING : The facility will not work if RCU_TRACE_ALLOC is hooked in @code{realloc()}} .

@node Non-Test Run Assertions
@section Non-Test Run Assertions

The assertion macros can be called in code locations other than the test function, or init or destroy functions. Assertion failures are recorded in separate database and can be dumped using the @code{rcu_dump_asserts()} interface. Furthermore, the user can register an assertion hook using the @code{rcu_set_assert()} to be able to receive assertion failure notifications. When an assertion failure is encountered, the framework invokes the function with a pointer to a RCU_FAILURE_RECORD.

Similar to most function entry points, the assertion hook is of type RCU_GENERIC_FUNCTION. The non-test run assertion failure records are deleted when the framework is destroyed. All non-test run assertion failures are implicitly non-fatal.

@node Exception Handling Mechanism
@section Exception Handling Mechanism

This is a try-catch mechanism implemented using non-local jump routines. This is not  considered a direct testing facility but the user can use it,  perhaps in other test codes, in implementing alternative error handling mechanism. Use this mechanism with extreme caution.

@table @code
@item @code{RCU_TRY}
    This macro signifies that the code after this statement can possible throw an exception.
@item @code{RCU_CATCH/RCU_END_CATCH}
    When an exception is thrown by a code after the RCU_TRY statement, the  code inside this macro pair will be executed. This is called the exception handler code. An exception can be further thrown inside this block.
@item @code{RCU_THROW}
    This macro is used for throwing a specific exception.
@end table

@strong{WARNING : No code must jump in or out between the RCU_TRY and RCU_CATCH blocks}.

@xref{Sample Test Codes #6}, for a sample usage of this mechanism.

@node Sample Test Codes
@appendix Sample Test Codes

@menu
* The Sample Functions:: The functions to be tested
* The Sample Test Functions:: The test functions
* Sample Test Codes #1:: Demonstrates the simplest test function
* Sample Test Codes #2:: Demonstrates the use of user-defined test module and test registry
* Sample Test Codes #3:: Demonstrates the use of test function table
* Sample Test Codes #4:: Demonstrates the use of test module table
* Sample Test Codes #5:: Demonstrates the use of memory leak check facility
* Sample Test Codes #6:: Demonstrates the use of exception handling mechanism
* Sample Test Codes #7:: Demonstrates the use of non-test run assertions
@end menu

@node The Sample Functions
@appendixsec The Sample Functions

@verbatiminclude rcunit_sample_app_functions.c

@node The Sample Test Functions
@appendixsec The Sample Test Functions

@xref{The Sample Functions}.

@verbatiminclude rcunit_sample_app_test_functions.c

@node  Sample Test Codes #1
@appendixsec Sample Test Codes #1

This sample demonstrates the simplest usage of the framework. Test functions are created and registered to the default test module, and a test run is performed.

@xref{The Sample Test Functions}.

@verbatiminclude rcunit_sample_app_1.c

@node  Sample Test Codes #2
@appendixsec Sample Test Codes #2

This sample demonstrates the creation and registration of a user-defined  test module and test registry. The test functions are then registered to the test module and a test run is performed.

@xref{The Sample Test Functions}.

@verbatiminclude rcunit_sample_app_2.c

@node  Sample Test Codes #3
@appendixsec Sample Test Codes #3

This sample demonstrates the use of a test function table. A user-defined test function table is created and registered to the default test module, and test run is performed.

@xref{The Sample Test Functions}.

@verbatiminclude rcunit_sample_app_3.c

@node  Sample Test Codes #4
@appendixsec Sample Test Codes #4

This sample demonstrates the use of a test module table. A user-defined test module table is created and registered to the default test registry.  A user-defined test function table is also created as part of the test module table entry. A test run is then performed.

@xref{The Sample Test Functions}.

@verbatiminclude rcunit_sample_app_4.c

@node  Sample Test Codes #5
@appendixsec Sample Test Codes #5

This sample demonstrates the use of the memory leak check facility

@verbatiminclude rcunit_sample_app_5.c

@node  Sample Test Codes #6
@appendixsec Sample Test Codes #6

This sample demonstrates the use of the exception handling mechanism

@verbatiminclude rcunit_sample_app_6.c

@node  Sample Test Codes #7
@appendixsec Sample Test Codes #7

This sample demonstrates the use of non-test run assertions

@verbatiminclude rcunit_sample_app_7.c

@node Sample Test Run Report
@appendix Sample Test Run Report

@menu
* HTML Test Tun Report::
* Plain Text Test Run Report::
@end menu

@node HTML Test Tun Report
@appendixsec HTML Test Tun Report

See @uref{rcunit_test_run_report.html}.

@node Plain Text Test Run Report
@appendixsec Plain Text Test Run Report

See @uref{rcunit_test_run_report.txt}.

@node Sample Log File
@appendix Sample Log File

@menu
* HTML Log::
* Plain Text Log::
@end menu

@node HTML Log
@appendixsec HTML Log

See @uref{rcunit_log.html}.

@node Plain Text Log
@appendixsec Plain Text Log

See @uref{rcunit_log.txt}.

@node Copying This Manual
@appendix Copying This Manual

@appendixsec The GNU Free Documentation License

@verbatiminclude fdl.txt

@node Submitting Bugs
@appendix Submitting Bugs

@uref{http://sourceforge.net/tracker/?func=add&group_id=177994&atid=883451}

@node Acknowledgements
@appendix Acknowledgements

@itemize
@item Sourceforge (@uref{http://sourceforge.net}) - For hosting this project
@item Mark Gamis (@email{emelgeek@@users.sourceforge.net}) - For the RCUNIT testing
@item Abigail Ong (@email{abbieong@@yahoo.com}) - For the comments and corrections to the RCUNIT manual
@item Erin Diaz (@email{ramfree26@@yahoo.com}) - For the open source stuff
@end itemize

@bye

